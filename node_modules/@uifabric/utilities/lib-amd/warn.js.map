{"version":3,"sources":["warn.ts"],"names":[],"mappings":";;;IAAA,IAAI,gBAAgB,GAA8B,IAAI,CAAC;IAMvD;;;;;;;;OAQG;IACH,0BACE,aAAqB,EACrB,KAAQ,EACR,cAA+B;QAE/B,GAAG,CAAC,CAAC,IAAM,QAAQ,IAAI,cAAc,CAAC,CAAC,CAAC;YACtC,EAAE,CAAC,CAAC,KAAK,IAAI,QAAQ,IAAI,KAAK,CAAC,CAAC,CAAC;gBAC/B,IAAI,kBAAkB,GAAM,aAAa,mBAAc,QAAQ,wCAAqC,CAAC;gBACrG,IAAM,mBAAmB,GAAG,cAAc,CAAC,QAAQ,CAAC,CAAC;gBAErD,EAAE,CAAC,CAAC,mBAAmB,CAAC,CAAC,CAAC;oBACxB,kBAAkB,IAAI,WAAS,mBAAmB,eAAY,CAAC;gBACjE,CAAC;gBACD,gBAAgB,CAAC,kBAAkB,CAAC,CAAC;YACvC,CAAC;QACH,CAAC;IACH,CAAC;IAhBD,4CAgBC;IAED,+BACE,aAAqB,EACrB,KAAQ,EACR,YAA6B;QAE7B,GAAG,CAAC,CAAC,IAAM,QAAQ,IAAI,YAAY,CAAC,CAAC,CAAC;YACpC,EAAE,CAAC,CAAC,KAAK,IAAI,QAAQ,IAAI,KAAK,IAAI,YAAY,CAAC,QAAQ,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC;gBAClE,gBAAgB,CACX,aAAa,mBAAc,QAAQ,sCAAiC,YAAY,CAAC,QAAQ,CAAC,6BAA0B,CACxH,CAAC;YACJ,CAAC;QACH,CAAC;IACH,CAAC;IAZD,sDAYC;IAED,cAAqB,OAAe;QAClC,EAAE,CAAC,CAAC,OAAO,IAAI,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC;YAC5B,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QACxB,CAAC;IACH,CAAC;IAJD,oBAIC;IAED;;;;;;OAMG;IACH,4BAAmC,eAA0C;QAC3E,gBAAgB,GAAG,eAAe,KAAK,SAAS,GAAG,IAAI,GAAG,eAAe,CAAC;IAC5E,CAAC;IAFD,gDAEC","file":"warn.js","sourcesContent":["let _warningCallback: (message: string) => void = warn;\r\n\r\nexport type ISettingsMap<T> = {\r\n  [P in keyof T]: string;\r\n};\r\n\r\n/**\r\n * Warns when a deprecated props are being used.\r\n *\r\n * @export\r\n * @param {string} componentName The name of the component being used.\r\n * @param {Object} props The props passed into the component.\r\n * @param {ISettingsMap} deprecationMap The map of deprecations, where key is the prop name and the value is\r\n * either null or a replacement prop name.\r\n */\r\nexport function warnDeprecations<P>(\r\n  componentName: string,\r\n  props: P,\r\n  deprecationMap: ISettingsMap<P>): void {\r\n\r\n  for (const propName in deprecationMap) {\r\n    if (props && propName in props) {\r\n      let deprecationMessage = `${componentName} property '${propName}' was used but has been deprecated.`;\r\n      const replacementPropName = deprecationMap[propName];\r\n\r\n      if (replacementPropName) {\r\n        deprecationMessage += ` Use '${replacementPropName}' instead.`;\r\n      }\r\n      _warningCallback(deprecationMessage);\r\n    }\r\n  }\r\n}\r\n\r\nexport function warnMutuallyExclusive<P>(\r\n  componentName: string,\r\n  props: P,\r\n  exclusiveMap: ISettingsMap<P>): void {\r\n\r\n  for (const propName in exclusiveMap) {\r\n    if (props && propName in props && exclusiveMap[propName] in props) {\r\n      _warningCallback(\r\n        `${componentName} property '${propName}' is mutually exclusive with '${exclusiveMap[propName]}'. Use one or the other.`\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nexport function warn(message: string): void {\r\n  if (console && console.warn) {\r\n    console.warn(message);\r\n  }\r\n}\r\n\r\n/**\r\n * Configures the warning callback. Passing in undefined will reset it to use the default\r\n * console.warn function.\r\n *\r\n * @export\r\n * @param {(message) => void} warningCallback\r\n */\r\nexport function setWarningCallback(warningCallback: (message: string) => void): void {\r\n  _warningCallback = warningCallback === undefined ? warn : warningCallback;\r\n}\r\n"],"sourceRoot":"..\\src"}
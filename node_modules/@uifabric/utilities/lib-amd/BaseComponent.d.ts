import * as React from 'react';
import { Async } from './Async';
import { EventGroup } from './EventGroup';
import { IDisposable } from './IDisposable';
import { ISettingsMap } from './warn';
export interface IBaseProps {
    componentRef?: any;
}
export declare class BaseComponent<P extends IBaseProps, S> extends React.Component<P, S> {
    /**
     * External consumers should override BaseComponent.onError to hook into error messages that occur from
     * exceptions thrown from within components.
     */
    static onError: ((errorMessage?: string, ex?: any) => void);
    /**
     * Controls whether the componentRef prop will be resolved by this component instance. If you are
     * implementing a passthrough (higher-order component), you would set this to false and pass through
     * the props to the inner component, allowing it to resolve the componentRef.
     *
     * @protected
     * @type {boolean}
     * @memberOf BaseComponent
     */
    protected _shouldUpdateComponentRef: boolean;
    private __async;
    private __events;
    private __disposables;
    private __resolves;
    private __className;
    /**
     * BaseComponent constructor
     * @param {P} props The props for the component.
     * @param {Object} context The context for the component.
     * value is the new name. If a prop is removed rather than renamed, leave the value undefined.
     */
    constructor(props?: P, context?: any);
    /** When the component will receive props, make sure the componentRef is updated. */
    componentWillReceiveProps(newProps?: P, newContext?: any): void;
    /** When the component has mounted, update the componentRef. */
    componentDidMount(): void;
    /** If we have disposables, dispose them automatically on unmount. */
    componentWillUnmount(): void;
    /** Gets the object's class name. */
    readonly className: string;
    /** Allows subclasses to push things to this._disposables to be auto disposed. */
    protected readonly _disposables: IDisposable[];
    /**
     * Gets the async instance associated with the component, created on demand. The async instance gives
     * subclasses a way to execute setTimeout/setInterval async calls safely, where the callbacks
     * will be cleared/ignored automatically after unmounting. The helpers within the async object also
     * preserve the this pointer so that you don't need to "bind" the callbacks.
     */
    protected readonly _async: Async;
    /**
     * Gets the event group instance assocaited with the component, created on demand. The event instance
     * provides on/off methods for listening to DOM (or regular javascript object) events. The event callbacks
     * will be automatically disconnected after unmounting. The helpers within the events object also
     * preserve the this reference so that you don't need to "bind" the callbacks.
     */
    protected readonly _events: EventGroup;
    /**
     * Helper to return a memoized ref resolver function.
     * @params refName Name of the member to assign the ref to.
     *
     * @examples
     * class Foo extends BaseComponent<...> {
     *   private _root: HTMLElement;
     *
     *   public render() {
     *     return <div ref={ this._resolveRef('_root') } />
     *   }
     * }
     */
    protected _resolveRef(refName: string): (ref: any) => any;
    /**
     * Updates the componentRef (by calling it with "this" when necessary.)
     */
    protected _updateComponentRef(currentProps: IBaseProps, newProps?: IBaseProps): void;
    /**
     * Warns when a deprecated props are being used.
     *
     * @protected
     * @param {ISettingsMap<P>} deprecationMap The map of deprecations, where key is the prop name and the value is
     * either null or a replacement prop name.
     *
     * @memberOf BaseComponent
     */
    protected _warnDeprecations(deprecationMap: ISettingsMap<P>): void;
    /**
     * Warns when props which are mutually exclusive with each other are both used.
     *
     * @protected
     * @param {ISettingsMap<P>} mutuallyExclusiveMap The map of mutually exclusive props.
     *
     * @memberOf BaseComponent
     */
    protected _warnMutuallyExclusive(mutuallyExclusiveMap: ISettingsMap<P>): void;
}
export declare function nullRender(): any;
